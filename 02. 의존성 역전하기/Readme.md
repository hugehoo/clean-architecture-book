# 02. 의존성 역전하기
- feat. 클린 아키텍처와 의존성 역전은 무슨 관계가 있는가

### 단일 책임 원칙
- `일반적인 해석` : 하나의 컴포넌트는 하나의 책임을 가진다.
- `실제 정의` : 컴포넌트를 변경하는 이유는 오직 하나 뿐이어야 한다.
- 아키텍처 관점에서 단일 책임 원칙이 갖는 의의는, 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해선 전혀 신경 쓸 필요가 없다는 것.

### 의존성 역전 원칙
- 일반적인 계층형 아키텍처에서 계층 간 의존성은 항상 아래 방향을 가리킨다. (웹 -> 도메인 -> 영속성)
- 상위 계층에서 하위 계층을 의존하는 형태로, 상위 계층이 변경 될 이유는 자신이 의존하는 다른 모든 계층에 있다. (변경될 이유가 더 많다)
- 도메인 계층이 영속성 계층을 의존하기 때문에 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다.
- 하지만 도메인 코드는 곧 애플리케이션의 핵심에 해당된다. 영속성 코드가 바뀐다고 하여 도메인 코드까지 변경될 필요는 없다. 
- `의존성 역전 원칙`을 이용하면 이 문제를 해결할 수 있다.

#### 의존성 역전 원칙 : 코드상의 어떤 의존성이든 그 방향을 바꿀 수 있다.
- 사실 의존성의 양쪽 코드를 모두 제어할 수 있을 때만 의존성을 역전할 수 있다.
- 가령 서드파티 라이브러이에 의존하면 해당 라이브러리를 제어할 수 없기 때문에 의존성은 역전시킬 수 없다.

1. 기존엔 영속성 계층에 있던 엔티티 코드를 도메인 계층으로 올린다. 
2. 영속성 계층에 있는 레포지토리는 이제 도메인 계층에 존재하는 엔티티를 의존해야 한다. (의존 방향이 바뀜)
3. 이 때 레포지토리의 인터페이스를 도메인 계층으로 올리는 대신, 레포지토리의 구현체는 그대로 영속성 계층에 둔다. 
4. 레포지토리의 구현체는 레포지토리 인터페이스에 의존하고 동시에 레포지토리 인터페이스는 엔티티에 의존한다. 
5. 이로써 의존성을 역전 시켰다. 의존성 역전 원칙의 도움으로 애플리케이션의 모든 컴포넌트의 의존성이 도메인 코드를 향하고 있다. 결국 엔티티가 변경 될 이유는 오직 자신에게만 있게 된다. (기꺼이 의존성을 역전시킨 목적)

- 영속성 계층이 도메인 계층에 의존하게 됨(기존과 달리 반대 방향으로 의존성이 생김)
- 도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고, 비즈니스 규칙에 집중할 수 있다.

- 클린아키텍처는 대가가 따른다. 
  - 도메인 계층이 영속성이나 UI 같은 외부 계층과 철저히 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야한다.
  - 그말은 즉슨, 도메인 계층에서 사용한 엔티티 클래스를 영속성 계층에서 함께 사용할 수 없고, 두 계층에서 각각 엔티티를 만들어야 한다. 복잡하지만, 이것이 바람직한 아키텍처다. 

### 배운 것
- 내가 도메인이라 생각했던 Entity 클래스는 사실 도메인과 별개로 존재할 수 있다. Entity 도 물론 도메인에 해당되긴 하지만, 이제껏 접한 @Table 어노테이션이 달린 엔티티 클래스는 그저 영속성 계층에서 접근하기 위한 도메인이다.
- 클린아키텍처에서 말하는 도메인은 도메인 계층에 존재하며 모든 의존성의 방향이 향하는 클래스를 의미한다.